"""  
Lambda function handler for processing PDF invoices and receipts using Amazon Textract.

This function is triggered by the upload of a PDF invoice or receipt to an S3 bucket. It initiates
an asynchronous analysis of the document using Amazon Textract's Start Expense Analysis operation. Once the
analysis is complete, the resulting JSON response is saved to another S3 bucket. 

Phase 1 of Lambda Development
"""
import json
import time
import logging
import boto3
from botocore.exceptions import ClientError


# Configure logging level
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()

def lambda_handler(event, context):
    """
    Lambda function handler
    Parameters:
    - event (dict): A dictionary containing information about the event that triggered the function.
                    In this case, it contains details about the uploaded file in the S3 bucket.
    - context (LambdaContext): An object containing runtime information for the Lambda function.

    Returns:
    - dict: A dictionary containing the HTTP status code and the JSON response generated by Textract.

    Raises:
    - Exception: If Textract processing fails or if the maximum wait time for processing is exceeded.

    Note:
    - The function uses the start_expense_analysis method to initiate the analysis asynchronously.
    - It periodically checks the status of the analysis using the get_expense_analysis method.
    - Once the analysis is successful, the JSON response is saved to the designated S3 bucket.
    - A timeout mechanism is implemented to prevent waiting indefinitely for Textract processing. 
    """

    # Retrieve the S3 bucket name and object key from the event
    bucket_name = event['Records'][0]['s3']['bucket']['name'] #extracts the name of the S3 bucket from the event data.
    object_key = event['Records'][0]['s3']['object']['key'] #extracts the key (i.e., the path) of the object (file) that triggered the event.
    
    # Extract filename from the object key
    filename = object_key.split('/')[-1] #[-1]: index is used to access the last element of the list returned by the split()

    # Initialize the Textract client
    textract_client = boto3.client('textract')
    
    try:
        # Invoke Textract's start_expense_analysis method on the uploaded PDF
        response = textract_client.start_expense_analysis(
            DocumentLocation={
                'S3Object': {
                    'Bucket': bucket_name,
                    'Name': object_key
                }
            }
            #OutputConfig={'S3Bucket': 'ccwebapp-textract-json',},# parameter speciffies s3 bucket to store any output artifacts 
        )
        # Retrieve the job ID from the start response
        job_id = response['JobId']
    except ClientError as e:
        logger.error(f"ClientError in start_expense_analysis for {object_key}: {e.response['Error']['Message']}")
    except Exception as e:
        logger.error(f"Failed to start expense analysis for {object_key} in {bucket_name}: {str(e)}")    

    
    try:
        textract_result = get_expense_analysis_with_retry(textract_client, job_id)
    except Exception as e:
        raise Exception(f"Failed to get Textract results after retries: {str(e)}")
    
    # Extract the JSON response from the Textract Dictionary result
    json_response = json.dumps(textract_result)
    
    s3_client = boto3.client('s3')
    try:
        s3_client.put_object(
            Bucket='ccwebapp-textract-json',
            Key=f'{filename}.json',
            Body=json_response
        )
    except ClientError as e:
        logger.error(f"ClientError in saving JSON to S3 for {filename}.json: {e.response['Error']['Message']}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in saving JSON to S3 for {filename}.json: {str(e)}")
        raise
    
    return {
        'statusCode': 200,
        'body': json_response
    }



def get_expense_analysis_with_retry(textract_client, job_id, max_attempts=5):
    """
    Retrieves the Textract expense analysis result with retry logic.

    Implements an exponential backoff strategy for retries to handle transient errors or rate limiting
    by the Textract service. This function polls the Textract service for the completion of the expense
    analysis job and returns the result once the job succeeds.

    Parameters:
    - textract_client (boto3.client): A Boto3 Textract client.
    - job_id (str): The job identifier for the Textract expense analysis request.
    - max_attempts (int): Maximum number of retry attempts. Default is 5.

    Returns:
    - dict: The JSON response from Textract containing the analysis result once the job status is 'SUCCEEDED'.

    Raises:
    - Exception: If the job status is 'FAILED', if all retry attempts are exhausted without success,
      or if an unexpected error occurs.
    """

    for attempt in range(max_attempts):
        try:
            # Wait before retrying using exponential backoff strategy
            time.sleep(2 ** attempt)  # Exponential backoff
            # Poll the Textract job status
            response = textract_client.get_expense_analysis(JobId=job_id)
            status = response['JobStatus']

            if status == 'SUCCEEDED':
                # Job succeeded, return the analysis result
                return response
            elif status == 'FAILED':
                # Job failed, log and raise an exception
                logger.error(f"Textract processing failed for JobId {job_id}")
                raise Exception('Textract processing failed')
        except ClientError as e:
            # Handle client errors from the Textract service, such as rate limits or other service issues
            logger.error(f"ClientError in get_expense_analysis for JobId {job_id}: {e.response['Error']['Message']}")
            if attempt >= max_attempts - 1:
                # Exhausted all attempts, re-raise the exception
                raise
        except Exception as e:
            # Handle unexpected errors
            logger.error(f"Unexpected error in get_expense_analysis for JobId {job_id}: {str(e)}")
            if attempt >= max_attempts - 1:
                # Exhausted all attempts, re-raise the exception
                raise
    # If the loop completes without returning or raising an exception for 'SUCCEEDED' status, raise a timeout exception
    raise Exception('Timeout: Textract processing took too long or exceeded retry attempts')
